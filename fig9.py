"""
LOC count
"""
from typing import List, Tuple
from collections import Counter
import re
from pathlib import Path
import os
import sys


def count_model_loc(lines: List[str]) -> Tuple[int, int]:
    in_policy_code = False
    block_indent = 0
    policy_loc = 0
    total_loc = 0
    for line in lines:
        indent = len(line) - len(line.lstrip())
        stripped = line.strip()
        is_comment = stripped.startswith("--")

        # Skip empty lines and comments
        if not stripped or is_comment:
            continue

        total_loc += 1

        # End of policy code by "}", this line should be counted as policy code
        if in_policy_code and stripped.endswith("}"):
            policy_loc += 1
            in_policy_code = False
            continue

        # End of policy code by indentation
        if in_policy_code and indent <= block_indent:
            in_policy_code = False

        # Start of policy code
        for s in ['predicate', 'policy', 'update', 'insert', 'read', 'assert']:
            if stripped.startswith(s):
                in_policy_code = True
                block_indent = indent
                break

        if in_policy_code and stripped:
            policy_loc += 1

    return (total_loc, policy_loc)


def is_trivial(annot: str) -> bool:
    m = re.match(
        r"{-@(.*)TaggedT<\s*{\s*\\\s*_\s*->\s*(?:True|False)\s*}\s*,\s*{\s*\\\s*_\s*->\s*(?:True|False)\s*}\s*>(.*)@-}", annot)
    if m:
        # If there is any other refinement we consider the annotation as non trivial
        return not re.fullmatch(r".*{[^}]+}.*", m[1] + m[2])
    return False


def count_haskell_loc(lines: List[str]) -> Counter[str]:
    count: Counter[str] = Counter()
    in_annot = False
    in_comment = False
    curr_annot: List[str] = []
    for line in lines:
        stripped = line.strip()
        line_comment = stripped.startswith("--")

        # Skip empty lines
        if not stripped or line_comment:
            continue

        # Skip cli args
        if re.fullmatch(r"{-@\s*LIQUID.*@-}", stripped):
            continue

        # Start of LH annotation
        if re.fullmatch(r"{-@.*", stripped):
            in_annot = True

        if in_annot:
            curr_annot.append(stripped)

        # End of LH annotation
        if re.fullmatch(r".*@-}", stripped):
            count['annot_count'] += 1
            count['annot_loc'] += len(curr_annot)
            if not is_trivial(''.join(curr_annot)):
                # print("non-trivial", ''.join(curr_annot))
                count['non_trivial_count'] += 1
                count['non_trivial_loc'] += len(curr_annot)
            # else:
            #     print("trivial", ''.join(curr_annot))
            curr_annot = []
            in_annot = False

        # Start of comment
        if re.fullmatch(r"{-.*", stripped):
            in_comment = True

        if not in_comment:
            count['code_loc'] += 1

        # End of comment
        if re.fullmatch(r".*-}", stripped):
            in_comment = False

    return count


def model_file_loc(filepath: Path) -> Counter[str]:
    with open(filepath, "r") as f:
        lines = f.readlines()
        (total_loc, policy_loc) = count_model_loc(lines)
        model_loc = total_loc - policy_loc
        return Counter(
            {
                "model_loc": model_loc,
                "policy_loc": policy_loc
            }
        )


def should_exclude_file(filepath: Path) -> bool:
    exclude = [
        "Model.hs",  # This file is autogenerated
        "Auth.hs",  # This file is the same in all projects
    ]
    for e in exclude:
        if e in str(filepath):
            return True
    return False


def haskell_loc(directory: Path) -> Counter[str]:
    total_count: Counter[str] = Counter()
    for filepath in directory.glob("src/**/*.hs"):
        if should_exclude_file(filepath):
            continue
        with open(filepath, "r") as f:
            lines = f.readlines()
            total_count += count_haskell_loc(lines)
    return total_count


def print_table(table: List[List[str]]):
    col_widths = [0] * len(table[0])
    for row in table:
        for i, col in enumerate(row):
            col_widths[i] = max(col_widths[i], len(col))
    sep = 2
    for i, row in enumerate(table):
        for width, col in zip(col_widths, row):
            padding = width - len(col)
            sys.stdout.write(col + " " * padding)
            sys.stdout.write(" " * sep)
        sys.stdout.write("\n")
        if i == 0:
            sys.stdout.write("-" * (sum(col_widths) + sep * len(col_widths) - sep))
            sys.stdout.write("\n")


if __name__ == "__main__":
    apps = {"Conference": Path("case-studies", "conf"), "Course": Path("case-studies", "course"),
            "WishList": Path("case-studies", "wishlist"), "Vontron": Path("voltron", "server"), "Disco": Path("disco", "server")}
    # apps = {"Disco": Path("disco", "server")}
    # apps = {"WishList": Path("case-studies", "wishlist")}

    table = [["App", "Server", "Models", "Policy", "Annot."]]
    for name, directory in apps.items():
        model = model_file_loc(Path(directory, "src", "Model.storm"))
        haskell = haskell_loc(directory)
        table.append([name, str(haskell["code_loc"]),
                      str(model["model_loc"]), str(model["policy_loc"]),
                      f"{haskell['annot_loc']} ({haskell['non_trivial_loc']})"])
    print_table(table)
