#!/usr/bin/env python3

import json
import re
import shutil
import subprocess
import sys
from pathlib import Path
from typing import List, Tuple, Counter


def count_model_loc(lines: List[str]) -> Tuple[int, int]:
    in_policy_code = False
    block_indent = 0
    policy_loc = 0
    total_loc = 0
    for line in lines:
        indent = len(line) - len(line.lstrip())
        stripped = line.strip()
        is_comment = stripped.startswith("--")

        # Skip empty lines and comments
        if not stripped or is_comment:
            continue

        total_loc += 1

        # End of policy code by "}", this line should be counted as policy code
        if in_policy_code and stripped.endswith("}"):
            policy_loc += 1
            in_policy_code = False
            continue

        # End of policy code by indentation
        if in_policy_code and indent <= block_indent:
            in_policy_code = False

        # Start of policy code
        for s in ['predicate', 'policy', 'update', 'insert', 'read', 'assert']:
            if stripped.startswith(s):
                in_policy_code = True
                block_indent = indent
                break

        if in_policy_code and stripped:
            policy_loc += 1

    return (total_loc, policy_loc)


def is_trivial(annot: str) -> bool:
    m = re.match(
        r"{-@(.*)TaggedT<\s*{\s*\\\s*_\s*->\s*(?:True|False)\s*}\s*,\s*{\s*\\\s*_\s*->\s*(?:True|False)\s*}\s*>(.*)@-}", annot)
    if m:
        # If there is any other refinement we consider the annotation as non trivial
        return not re.fullmatch(r".*{[^}]+}.*", m[1] + m[2])
    return False


def count_haskell_loc(lines: List[str]) -> Counter[str]:
    count: Counter[str] = Counter()
    in_annot = False
    in_comment = False
    curr_annot: List[str] = []
    for line in lines:
        stripped = line.strip()
        line_comment = stripped.startswith("--")

        # Skip empty lines
        if not stripped or line_comment:
            continue

        # Skip cli args
        if re.fullmatch(r"{-@\s*LIQUID.*@-}", stripped):
            continue

        # Start of LH annotation
        if re.fullmatch(r"{-@.*", stripped):
            in_annot = True

        if in_annot:
            curr_annot.append(stripped)

        # End of LH annotation
        if re.fullmatch(r".*@-}", stripped):
            count['annot_count'] += 1
            count['annot_loc'] += len(curr_annot)
            if not is_trivial(''.join(curr_annot)):
                # print("non-trivial", ''.join(curr_annot))
                count['non_trivial_count'] += 1
                count['non_trivial_loc'] += len(curr_annot)
            # else:
            #     print("trivial", ''.join(curr_annot))
            curr_annot = []
            in_annot = False

        # Start of comment
        if re.fullmatch(r"{-.*", stripped):
            in_comment = True

        if not in_comment:
            count['code_loc'] += 1

        # End of comment
        if re.fullmatch(r".*-}", stripped):
            in_comment = False

    return count


def model_file_loc(filepath: Path) -> Counter[str]:
    with open(filepath, "r") as f:
        lines = f.readlines()
        (total_loc, policy_loc) = count_model_loc(lines)
        model_loc = total_loc - policy_loc
        return Counter(
            {
                "model_loc": model_loc,
                "policy_loc": policy_loc
            }
        )


def should_exclude_file(filepath: Path) -> bool:
    exclude = [
        "Model.hs",  # This file is autogenerated
        "Auth.hs",  # This file is the same in all projects
    ]
    for e in exclude:
        if e in str(filepath):
            return True
    return False


def haskell_loc(directory: Path) -> Counter[str]:
    total_count: Counter[str] = Counter()
    for filepath in directory.glob("src/**/*.hs"):
        if should_exclude_file(filepath):
            continue
        with open(filepath, "r") as f:
            lines = f.readlines()
            total_count += count_haskell_loc(lines)
    return total_count


def client_loc(directory: Path) -> int:
    res = subprocess.run(['tokei', '-t', 'Vue,Javascript,TypeScript',
                          '-o', 'json', str(directory)], capture_output=True)
    output = json.loads(res.stdout)
    javascript = output.get('JavaScript', {}).get('code', 0)
    typescript = output.get('TypeScript', {}).get('code', 0)

    vue = output.get('Vue', {}).get('children', {})
    vue_css = sum(child.get('stats', {}).get('code', 0)
                  for child in vue.get('Css', []))
    vue_html = sum(child.get('stats', {}).get('code', 0)
                   for child in vue.get('Html', []))
    vue_javascript = sum(child.get('stats', {}).get('code', 0)
                         for child in vue.get('JavaScript', []))
    # return javascript + typescript + vue_html + vue_css + vue_javascript
    return javascript + typescript + vue_javascript


def print_table(table: List[List[str]]):
    col_widths = [0] * len(table[0])
    for row in table:
        for i, col in enumerate(row):
            col_widths[i] = max(col_widths[i], len(col))
    sep = 2
    for i, row in enumerate(table):
        for j, col in enumerate(row):
            width = col_widths[j]
            padding = width - len(col)
            if j > 0:
                sys.stdout.write(" " * padding)
            sys.stdout.write(col)
            if j == 0:
                sys.stdout.write(" " * padding)
            sys.stdout.write(" " * sep)
        sys.stdout.write("\n")
        if i == 0 or i == len(table) - 1:
            sys.stdout.write("-" * (sum(col_widths) + sep * len(col_widths) - sep))
            sys.stdout.write("\n")


if __name__ == "__main__":
    case_studies = {"Conference": Path("case-studies", "conf"), "Course": Path(
        "case-studies", "course"), "WishList": Path("case-studies", "wishlist")}
    apps = {"Voltron": Path("voltron"), "Disco": Path("disco")}

    has_tokei = shutil.which('tokei') is not None

    table = [["App", "Server", "Models", "Policy", "Client", "Annot."]]

    for name, directory in case_studies.items():
        model = model_file_loc(Path(directory, "src", "Model.storm"))
        haskell = haskell_loc(directory)
        table.append([name, str(haskell["code_loc"]),
                      str(model["model_loc"]), str(model["policy_loc"]),
                      "-",
                      f"{haskell['annot_loc']} ({haskell['non_trivial_loc']})"])

    for name, directory in apps.items():
        model = model_file_loc(Path(directory, "server", "src", "Model.storm"))
        haskell = haskell_loc(Path(directory, "server"))
        if has_tokei:
            client = str(client_loc(Path(directory, 'client')))
        else:
            client = "-"
        table.append([name, str(haskell["code_loc"]),
                      str(model["model_loc"]), str(model["policy_loc"]),
                      client,
                      f"{haskell['annot_loc']} ({haskell['non_trivial_loc']})"])
    print_table(table)

    if not has_tokei:
        print()
        print("Warning: `tokei` is required to count client code")
